/*************

Tilemap.ts

This is to deal with the tilemap, the map of tiles on the game map where each tile can be a collidable object.
So this will deal with things like the floor and walls and other terrain

The tilemap will be utilise the tilemap.json 's generated by superpowers and in with the rest of the client stuff in $(projectroot)/Build

A large amount of this code was coppied and adapted from the Arcade2Dphysics used in the superpowers html5 engine
    - git hub source 
        https://github.com/superpowers/superpowers-game/blob/master/plugins/default/arcadePhysics2D/components/index.ts#L88

Code Other code to do with tilemaps and tileassets comes from the tileMap plugin
    -git hub source
        https://github.com/superpowers/superpowers-game/blob/be6d34744f8ab449ee63024698e670d67d6b26d6/plugins/default/tileMap

**************/
import Hitbox from "./Hitbox"
import Vector from "./Vector"
import TileMapAsset from "./TileMapAsset"
import TileSetAsset from "./TileSetAsset"

export default class Tilemap
{
    public tileSetAsset;
    public tileMapAsset;
    public mapToSceneFactor;
    public epsilon;
    public position;
    public layersIndex;

    constructor(inTMP, inTSA)
    {
        this.epsilon = 0.0001;
        this.tileMapAsset = new TileMapAsset(inTMP);
        this.tileSetAsset = new TileSetAsset(inTSA);

        // Copied from Arcade2DPhysics (see Hitbox.ts)
        this.mapToSceneFactor = {
            x: this.tileSetAsset.tsa.grid.width / this.tileMapAsset.tmp.pixelsPerUnit,
            y: this.tileSetAsset.tsa.grid.height / this.tileMapAsset.tmp.pixelsPerUnit,
        };

        this.layersIndex = [];
        for(var i = 0; i <this.tileMapAsset.tmp.layers.length; i++)
        {
            this.layersIndex[i] = i;
        }



        this.position = new Vector();
        this.position.x = 0;
        this.position.y = 0;
    }



    collides(body1, body2 = this)
    {
        // These will all get recalculated
        body1.touches.top = false;
        body1.touches.bottom = false;
        body1.touches.right = false;
        body1.touches.left = false;

        this.checkTileMap(body1, body2, true)

    }

    // Body2 should be the tilemap, body1 should be a hitbox
    checkTileMap(body1, body2, moveBody: boolean) {
        function checkX(epsilon) {
          // Checks whcih side of the box to colide with
          const x = (body1.deltaX() < 0) ?
            Math.floor((body1.position.x - body2.position.x - body1.width / 2) / body2.mapToSceneFactor.x) :
            Math.floor((body1.position.x - body2.position.x + body1.width / 2 - epsilon) / body2.mapToSceneFactor.x);
          const y = body1.position.y - body2.position.y - body1.height / 2 + epsilon;
          const testedHeight = body1.height - 3 * epsilon;
          const totalPoints = Math.ceil(testedHeight / body2.mapToSceneFactor.y);

          for (let point = 0; point <= totalPoints; point++) {
            for (const layer of body2.layersIndex) {
              const tile = body2.tileMapAsset.getTileAt(layer, x, Math.floor((y + point * testedHeight / totalPoints) / body2.mapToSceneFactor.y));
              //console.log(tile);

              let collide = false;
              if (body2.tileSetPropertyName != null) collide = body2.tileSetAsset.getTileProperties(tile)[body2.tileSetPropertyName] != null;
              //else if (tile !== -1) collide = true;
              if(tile !== 0) collide = true;

              if (!collide) continue;

              if (moveBody) {
                body1.velocity.x = -body1.velocity.x * body1.bounce.x;

                if (body1.deltaX() < 0) {
                  body1.position.x = (x + 1) * body2.mapToSceneFactor.x + body2.position.x + body1.width / 2;
                  body1.touches.left = true;
                } else {
                  body1.position.x = (x) * body2.mapToSceneFactor.x + body2.position.x - body1.width / 2;
                  body1.touches.right = true;
                }
              }

              return true;
            }
          }
          return false;
        }

        function checkY(epsilon) {
          const x = body1.position.x - body2.position.x - body1.width / 2 + epsilon;
          const y = (body1.deltaY() < 0) ?
            Math.floor((body1.position.y - body2.position.y - body1.height / 2) / body2.mapToSceneFactor.y) :
            Math.floor((body1.position.y - body2.position.y + body1.height / 2 - epsilon) / body2.mapToSceneFactor.y);
          const testedWidth = body1.width - 3 * epsilon;
          const totalPoints = Math.ceil(testedWidth / body2.mapToSceneFactor.x);

          for (let point = 0; point <= totalPoints; point++) {
            for (const layer of body2.layersIndex) {
              const tile = body2.tileMapAsset.getTileAt(layer, Math.floor((x + point * testedWidth / totalPoints) / body2.mapToSceneFactor.x), y);

              //console.log(tile);
              let collide = false;
              if (body2.tileSetPropertyName != null) collide = body2.tileSetAsset.getTileProperties(tile)[body2.tileSetPropertyName] != null;
              //else if (tile !== -1) collide = true;
              if(tile !== 0) collide = true;

              if (!collide) continue;


              if (moveBody) {
                body1.velocity.y = -body1.velocity.y * body1.bounce.y;

                if (body1.deltaY() < 0) {
                  body1.position.y = (y + 1) * body2.mapToSceneFactor.y + body2.position.y + body1.height / 2;
                  body1.touches.bottom = true;
                } else {
                  body1.position.y = (y) * body2.mapToSceneFactor.y + body2.position.y - body1.height / 2;
                  body1.touches.top = true;
                }
              }

              return true;
            }
          }
          return false;
        }

        const x = body1.position.x;
        body1.position.x = body1.previousPosition.x;

        let gotCollision = false;
        if (checkY(this.epsilon)) gotCollision = true;
        body1.position.x = x;
        if (checkX(this.epsilon)) gotCollision = true;

        return gotCollision;
    }
}
